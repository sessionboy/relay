<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Mutations · Relay</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations – operations that consist of writes to the data store followed by a fetch of any changed fields.&lt;/p&gt;
"/><meta name="docsearch:version" content="v1.7.0"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Mutations · Relay"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/relay/index.html"/><meta property="og:description" content="&lt;p&gt;Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations – operations that consist of writes to the data store followed by a fetch of any changed fields.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/relay/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/relay/css/main.css"/><script src="/relay/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/relay/en"><img class="logo" src="/relay/img/relay-white.svg" alt="Relay"/><h2 class="headerTitleWithLogo">Relay</h2></a><a href="/relay/en/versions.html"><h3>v1.7.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/relay/docs/en/v1.7.0/introduction-to-relay.html" target="_self">Docs</a></li><li class=""><a href="/relay/en/help.html" target="_self">Support</a></li><li class=""><a href="https://github.com/facebook/relay" target="_self">GitHub</a></li><li class=""><a target="_self"></a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/relay/edit/master/docs/Classic-Guides-Mutations.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Mutations</h1></header><article><div><span><p>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations – operations that consist of writes to the data store followed by a fetch of any changed fields.</p>
<h2><a class="anchor" aria-hidden="true" id="a-complete-example"></a><a href="#a-complete-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A complete example</h2>
<p>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass <code>Relay.Mutation</code> to create a custom mutation that we can use to like a story.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeStoryMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  <span class="hljs-comment">// This method should return a GraphQL operation that represents</span>
  <span class="hljs-comment">// the mutation to be performed. This presumes that the server</span>
  <span class="hljs-comment">// implements a mutation type named ‘likeStory’.</span>
  getMutation() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`mutation {likeStory}`;
  }
  <span class="hljs-comment">// Use this method to prepare the variables that will be used as</span>
  <span class="hljs-comment">// input to the mutation. Our ‘likeStory’ mutation takes exactly</span>
  <span class="hljs-comment">// one variable as input – the ID of the story to like.</span>
  getVariables() {
    <span class="hljs-keyword">return</span> {storyID: <span class="hljs-keyword">this</span>.props.story.id};
  }
  <span class="hljs-comment">// Use this method to design a ‘fat query’ – one that represents every</span>
  <span class="hljs-comment">// field in your data model that could change as a result of this mutation.</span>
  <span class="hljs-comment">// Liking a story could affect the likers count, the sentence that</span>
  <span class="hljs-comment">// summarizes who has liked a story, and the fact that the viewer likes the</span>
  <span class="hljs-comment">// story or not. Relay will intersect this query with a ‘tracked query’</span>
  <span class="hljs-comment">// that represents the data that your application actually uses, and</span>
  <span class="hljs-comment">// instruct the server to include only those fields in its response.</span>
  getFatQuery() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">LikeStoryPayload</span> {
        story {
          likers {
            count,
          },
          likeSentence,
          viewerDoesLike,
        },
      }
    `;
  }
  <span class="hljs-comment">// These configurations advise Relay on how to handle the LikeStoryPayload</span>
  <span class="hljs-comment">// returned by the server. Here, we tell Relay to use the payload to</span>
  <span class="hljs-comment">// change the fields of a record it already has in the store. The</span>
  <span class="hljs-comment">// key-value pairs of ‘fieldIDs’ associate field names in the payload</span>
  <span class="hljs-comment">// with the ID of the record that we want updated.</span>
  getConfigs() {
    <span class="hljs-keyword">return</span> [{
      <span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-symbol">'FIELDS_CHANG</span>E',
      fieldIDs: {
        story: <span class="hljs-keyword">this</span>.props.story.id,
      },
    }];
  }
  <span class="hljs-comment">// This mutation has a hard dependency on the story's ID. We specify this</span>
  <span class="hljs-comment">// dependency declaratively here as a GraphQL query fragment. Relay will</span>
  <span class="hljs-comment">// use this fragment to ensure that the story's ID is available wherever</span>
  <span class="hljs-comment">// this mutation is used.</span>
  static fragments = {
    story: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">Story</span> {
        id,
      }
    `,
  };
}
</code></pre>
<p>Here's an example of this mutation in use by a <code>LikeButton</code> component:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  _handleLike = () =&gt; {
    <span class="hljs-comment">// To perform a mutation, pass an instance of one to</span>
    <span class="hljs-comment">// `this.props.relay.commitUpdate`</span>
    <span class="hljs-keyword">this</span>.props.relay.commitUpdate(
      <span class="hljs-keyword">new</span> <span class="hljs-type">LikeStoryMutation</span>({story: <span class="hljs-keyword">this</span>.props.story})
    );
  }
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;
        {<span class="hljs-keyword">this</span>.props.story.viewerDoesLike
          ? <span class="hljs-symbol">'You</span> like <span class="hljs-keyword">this</span>'
          : &lt;button onClick={<span class="hljs-keyword">this</span>._handleLike}&gt;<span class="hljs-type">Like</span> <span class="hljs-keyword">this</span>&lt;/button&gt;
        }
      &lt;/div&gt;
    );
  }
}

module.exports = <span class="hljs-type">Relay</span>.createContainer(<span class="hljs-type">LikeButton</span>, {
  fragments: {
    <span class="hljs-comment">// You can compose a mutation's query fragments like you would those</span>
    <span class="hljs-comment">// of any other RelayContainer. This ensures that the data depended</span>
    <span class="hljs-comment">// upon by the mutation will be fetched and ready for use.</span>
    story: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">Story</span> {
        viewerDoesLike,
        ${<span class="hljs-type">LikeStoryMutation</span>.getFragment(<span class="hljs-symbol">'stor</span>y')},
      }
    `,
  },
});
</code></pre>
<p>In this particular example, the only field that the <code>LikeButton</code> cares about is <code>viewerDoesLike</code>. That field will form part of the tracked query that Relay will intersect with the fat query of <code>LikeStoryMutation</code> to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the <code>LikeButton</code> need not worry about requesting them explicitly.</p>
<h2><a class="anchor" aria-hidden="true" id="mutation-props"></a><a href="#mutation-props" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutation props</h2>
<p>Any props that we pass to the constructor of a mutation will become available to its instance methods as <code>this.props</code>. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeStoryMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  static fragments = {
    story: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">Story</span> {
        id,
        viewerDoesLike,
      }
    `,
  };
  getMutation() {
    <span class="hljs-comment">// Here, viewerDoesLike is guaranteed to be available.</span>
    <span class="hljs-comment">// We can use it to make this mutation polymorphic.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.story.viewerDoesLike
      ? <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`mutation {unlikeStory}`
      : <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`mutation {likeStory}`;
  }
  <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="fragment-variables"></a><a href="#fragment-variables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fragment variables</h2>
<p>Like it can be done with <a href="guides-containers.html">Relay containers</a>, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RentMovieMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  static initialVariables = {
    format: <span class="hljs-symbol">'h</span>d',
    lang: <span class="hljs-symbol">'en</span>-<span class="hljs-type">CA</span>',
  };
  static prepareVariables = (prevVariables) =&gt; {
    <span class="hljs-keyword">var</span> overrideVariables = {};
    <span class="hljs-keyword">if</span> (navigator.language) {
      overrideVariables.lang = navigator.language;
    }
    <span class="hljs-keyword">var</span> formatPreference = localStorage.getItem(<span class="hljs-symbol">'formatPreferenc</span>e');
    <span class="hljs-keyword">if</span> (formatPreference) {
      overrideVariables.format = formatPreference;
    }
    <span class="hljs-keyword">return</span> {...prevVariables, ...overrideVariables};
  };
  static fragments = {
    <span class="hljs-comment">// Now we can use the variables we've prepared to fetch movies</span>
    <span class="hljs-comment">// appropriate for the viewer's locale and preferences</span>
    movie: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">Movie</span> {
        posterImage(lang: $lang) { url },
        trailerVideo(format: $format, lang: $lang) { url },
      }
    `,
  };
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="the-fat-query"></a><a href="#the-fat-query" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The fat query</h2>
<p>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</p>
<ul>
<li>both people's friend count will increment</li>
<li>an edge representing the new friend will be added to the viewer's <code>friends</code> connection</li>
<li>an edge representing the viewer will be added to the new friend's <code>friends</code> connection</li>
<li>the viewer's friendship status with the requester will change</li>
</ul>
<p>Design a fat query that covers every possible field that could change:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AcceptFriendRequestMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  getFatQuery() {
    <span class="hljs-comment">// This presumes that the server-side implementation of this mutation</span>
    <span class="hljs-comment">// returns a payload of type `AcceptFriendRequestPayload` that exposes</span>
    <span class="hljs-comment">// `friendEdge`, `friendRequester`, and `viewer` fields.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">AcceptFriendRequestPayload</span> {
        friendEdge,
        friendRequester {
          friends,
          friendshipStatusWithViewer,
        },
        viewer {
          friends,
        },
      }
    `;
  }
}
</code></pre>
<p>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like <code>friendEdge</code> and <code>friends</code>) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that <em>anything</em> under those non-scalar fields may change as a result of this mutation.</p>
<blockquote>
<p>Note</p>
<p>When designing a fat query, consider <em>all</em> of the data that might change as a result of the mutation – not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a ‘tracked query’ of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="mutator-configuration"></a><a href="#mutator-configuration" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutator configuration</h2>
<p>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</p>
<h3><a class="anchor" aria-hidden="true" id="fields-change"></a><a href="#fields-change" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>FIELDS_CHANGE</code></h3>
<p>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</p>
<h4><a class="anchor" aria-hidden="true" id="arguments"></a><a href="#arguments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments</h4>
<ul>
<li><p><code>fieldIDs: {[fieldName: string]: DataID | Array&lt;DataID&gt;}</code></p>
<p>A map between a <code>fieldName</code> in the response and one or more DataIDs in the store.</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="example"></a><a href="#example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example</h4>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RenameDocumentMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  <span class="hljs-comment">// This mutation declares a dependency on a document's ID</span>
  static fragments = {
    document: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`fragment on <span class="hljs-type">Document</span> { id }`,
  };
  <span class="hljs-comment">// We know that only the document's name can change as a result</span>
  <span class="hljs-comment">// of this mutation, and specify it here in the fat query.</span>
  getFatQuery() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">RenameDocumentMutationPayload</span> { updatedDocument { name } }
    `;
  }
  getVariables() {
    <span class="hljs-keyword">return</span> {id: <span class="hljs-keyword">this</span>.props.document.id, newName: <span class="hljs-keyword">this</span>.props.newName};
  }
  getConfigs() {
    <span class="hljs-keyword">return</span> [{
      <span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-symbol">'FIELDS_CHANG</span>E',
      <span class="hljs-comment">// Correlate the `updatedDocument` field in the response</span>
      <span class="hljs-comment">// with the DataID of the record we would like updated.</span>
      fieldIDs: {updatedDocument: <span class="hljs-keyword">this</span>.props.document.id},
    }];
  }
  <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="node-delete"></a><a href="#node-delete" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NODE_DELETE</code></h3>
<p>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</p>
<h4><a class="anchor" aria-hidden="true" id="arguments-1"></a><a href="#arguments-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments</h4>
<ul>
<li><p><code>parentName: string</code></p>
<p>The field name in the response that represents the parent of the connection</p></li>
<li><p><code>parentID?: string</code></p>
<p>The DataID of the parent node that contains the connection. This argument is optional.</p></li>
<li><p><code>connectionName: string</code></p>
<p>The field name in the response that represents the connection</p></li>
<li><p><code>deletedIDFieldName: string</code></p>
<p>The field name in the response that contains the DataID of the deleted node</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="example-1"></a><a href="#example-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example</h4>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DestroyShipMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  <span class="hljs-comment">// This mutation declares a dependency on an enemy ship's ID</span>
  <span class="hljs-comment">// and the ID of the faction that ship belongs to.</span>
  static fragments = {
    ship: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`fragment on <span class="hljs-type">Ship</span> { id, faction { id } }`,
  };
  <span class="hljs-comment">// Destroying a ship will remove it from a faction's fleet, so we</span>
  <span class="hljs-comment">// specify the faction's ships connection as part of the fat query.</span>
  getFatQuery() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">DestroyShipMutationPayload</span> {
        destroyedShipID,
        faction { ships },
      }
    `;
  }
  getConfigs() {
    <span class="hljs-keyword">return</span> [{
      <span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-symbol">'NODE_DELET</span>E',
      parentName: <span class="hljs-symbol">'factio</span>n',
      parentID: <span class="hljs-keyword">this</span>.props.ship.faction.id,
      connectionName: <span class="hljs-symbol">'ship</span>s',
      deletedIDFieldName: <span class="hljs-symbol">'destroyedShipI</span>D',
    }];
  }
  <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="range-add"></a><a href="#range-add" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>RANGE_ADD</code></h3>
<p>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</p>
<h4><a class="anchor" aria-hidden="true" id="arguments-2"></a><a href="#arguments-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments</h4>
<ul>
<li><p><code>parentName: string</code></p>
<p>The field name in the response that represents the parent of the connection</p></li>
<li><p><code>parentID?: string</code></p>
<p>The DataID of the parent node that contains the connection. This argument is optional.</p></li>
<li><p><code>connectionName: string</code></p>
<p>The field name in the response that represents the connection</p></li>
<li><p><code>edgeName: string</code></p>
<p>The field name in the response that represents the newly created edge</p></li>
<li><p><code>rangeBehaviors: {[call: string]: GraphQLMutatorConstants.RANGE_OPERATIONS} | (connectionArgs: {[argName: string]: string}) =&gt; $Enum&lt;GraphQLMutatorConstants.RANGE_OPERATIONS&gt;</code></p>
<p>A map between printed, dot-separated GraphQL calls <em>in alphabetical order</em> and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</p></li>
</ul>
<p>For example, <code>rangeBehaviors</code> could be written this way:</p>
<pre><code class="hljs">const rangeBehaviors = {
  // <span class="hljs-keyword">When</span> the ships <span class="hljs-keyword">connection</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> under the influence
  // <span class="hljs-keyword">of</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">call</span>, append the ship <span class="hljs-keyword">to</span> the <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> the <span class="hljs-keyword">connection</span>
  <span class="hljs-string">''</span>: <span class="hljs-string">'append'</span>,
  // Prepend the ship, wherever the <span class="hljs-keyword">connection</span> <span class="hljs-keyword">is</span> sorted <span class="hljs-keyword">by</span> age
  <span class="hljs-string">'orderby(newest)'</span>: <span class="hljs-string">'prepend'</span>,
};
</code></pre>
<p>Or this way, with the same results:</p>
<pre><code class="hljs">const rangeBehaviors = <span class="hljs-function"><span class="hljs-params">({orderby})</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (orderby === <span class="hljs-string">'newest'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'prepend'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'append'</span>;
  }
};

</code></pre>
<p>Behaviors can be one of <code>'append'</code>, <code>'ignore'</code>, <code>'prepend'</code>, <code>'refetch'</code>, or <code>'remove'</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="example-2"></a><a href="#example-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example</h4>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntroduceShipMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  <span class="hljs-comment">// This mutation declares a dependency on the faction</span>
  <span class="hljs-comment">// into which this ship is to be introduced.</span>
  static fragments = {
    faction: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`fragment on <span class="hljs-type">Faction</span> { id }`,
  };
  <span class="hljs-comment">// Introducing a ship will add it to a faction's fleet, so we</span>
  <span class="hljs-comment">// specify the faction's ships connection as part of the fat query.</span>
  getFatQuery() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">IntroduceShipPayload</span> {
        faction { ships },
        newShipEdge,
      }
    `;
  }
  getConfigs() {
    <span class="hljs-keyword">return</span> [{
      <span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-symbol">'RANGE_AD</span>D',
      parentName: <span class="hljs-symbol">'factio</span>n',
      parentID: <span class="hljs-keyword">this</span>.props.faction.id,
      connectionName: <span class="hljs-symbol">'ship</span>s',
      edgeName: <span class="hljs-symbol">'newShipEdg</span>e',
      rangeBehaviors: {
        <span class="hljs-comment">// When the ships connection is not under the influence</span>
        <span class="hljs-comment">// of any call, append the ship to the end of the connection</span>
        '': <span class="hljs-symbol">'appen</span>d',
        <span class="hljs-comment">// Prepend the ship, wherever the connection is sorted by age</span>
        <span class="hljs-symbol">'orderby</span>(newest)': <span class="hljs-symbol">'prepen</span>d',
      },
    }];
  }
  <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="range-delete"></a><a href="#range-delete" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>RANGE_DELETE</code></h3>
<p>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</p>
<h4><a class="anchor" aria-hidden="true" id="arguments-3"></a><a href="#arguments-3" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments</h4>
<ul>
<li><p><code>deletedIDFieldName: string | Array&lt;string&gt;</code></p>
<p>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</p></li>
<li><p><code>pathToConnection: Array&lt;string&gt;</code></p>
<p>An array containing the field names between the parent and the connection, including the parent and the connection</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="example-3"></a><a href="#example-3" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example</h4>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveTagMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  <span class="hljs-comment">// This mutation declares a dependency on the</span>
  <span class="hljs-comment">// todo from which this tag is being removed.</span>
  static fragments = {
    todo: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`fragment on <span class="hljs-type">Todo</span> { id }`,
  };
  <span class="hljs-comment">// Removing a tag from a todo will affect its tags connection</span>
  <span class="hljs-comment">// so we specify it here as part of the fat query.</span>
  getFatQuery() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">RemoveTagMutationPayload</span> {
        todo { tags },
        removedTagIDs,
      }
    `;
  }
  getConfigs() {
    <span class="hljs-keyword">return</span> [{
      <span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-symbol">'RANGE_DELET</span>E',
      deletedIDFieldName: <span class="hljs-symbol">'removedTagID</span>s',
      pathToConnection: [<span class="hljs-symbol">'tod</span>o', <span class="hljs-symbol">'tag</span>s'],
    }];
  }
  <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="required-children"></a><a href="#required-children" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>REQUIRED_CHILDREN</code></h3>
<p>A <code>REQUIRED_CHILDREN</code> config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</p>
<p>Data fetched as a result of a <code>REQUIRED_CHILDREN</code> config is not written into the client store, but you can add code that processes it in the <code>onSuccess</code> callback that you pass into <code>commitUpdate()</code>:</p>
<pre><code class="hljs"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.props</span><span class="hljs-selector-class">.relay</span><span class="hljs-selector-class">.commitUpdate</span>(
  <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">CreateCouponMutation</span>(),
  {
    <span class="hljs-attribute">onSuccess</span>: response =&gt; this.<span class="hljs-built_in">setState</span>({
      couponCount: response.coupons.length,
    }),
  }
);
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="arguments-4"></a><a href="#arguments-4" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments</h4>
<ul>
<li><code>children: Array&lt;RelayQuery.Node&gt;</code></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="example-4"></a><a href="#example-4" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example</h4>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateCouponMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation&lt;Props&gt;</span> </span>{
  getMutation() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`mutation {
      create_coupon(data: $input)
    }`;
  }

  getFatQuery() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      <span class="hljs-comment">// Note the use of `pattern: true` here to show that this</span>
      <span class="hljs-comment">// connection field is to be used for pattern-matching only</span>
      <span class="hljs-comment">// (to determine what to fetch) and that Relay shouldn't</span>
      <span class="hljs-comment">// require the usual connection arguments like (`first` etc)</span>
      <span class="hljs-comment">// to be present.</span>
      fragment on <span class="hljs-type">CouponCreatePayload</span> <span class="hljs-meta">@relay</span>(pattern: <span class="hljs-literal">true</span>) {
        coupons
      }
    `;
  }

  getConfigs() {
    <span class="hljs-keyword">return</span> [{
      <span class="hljs-comment">// If we haven't shown the coupons in the UI at the time the</span>
      <span class="hljs-comment">// mutation runs, they've never been fetched and the `coupons`</span>
      <span class="hljs-comment">// field in the fat query would normally be ignored.</span>
      <span class="hljs-comment">// `REQUIRED_CHILDREN` forces it to be retrieved anyway.</span>
      <span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-type">RelayMutationType</span>.<span class="hljs-type">REQUIRED_CHILDREN</span>,
      children: [
        <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
          fragment on <span class="hljs-type">CouponCreatePayload</span> {
            coupons
          }
        `,
      ],
    }];
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="optimistic-updates"></a><a href="#optimistic-updates" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optimistic updates</h2>
<p>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</p>
<p>Let's craft an optimistic response for the <code>LikeStoryMutation</code> example above:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeStoryMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-comment">// Here's the fat query from before</span>
  getFatQuery() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">LikeStoryPayload</span> {
        story {
          likers {
            count,
          },
          likeSentence,
          viewerDoesLike,
        },
      }
    `;
  }
  <span class="hljs-comment">// Let's craft an optimistic response that mimics the shape of the</span>
  <span class="hljs-comment">// LikeStoryPayload, as well as the values we expect to receive.</span>
  getOptimisticResponse() {
    <span class="hljs-keyword">return</span> {
      story: {
        id: <span class="hljs-keyword">this</span>.props.story.id,
        likers: {
          count: <span class="hljs-keyword">this</span>.props.story.likers.count + (<span class="hljs-keyword">this</span>.props.story.viewerDoesLike ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>),
        },
        viewerDoesLike: !<span class="hljs-keyword">this</span>.props.story.viewerDoesLike,
      },
    };
  }
  <span class="hljs-comment">// To be able to increment the likers count, and flip the viewerDoesLike</span>
  <span class="hljs-comment">// bit, we need to ensure that those pieces of data will be available to</span>
  <span class="hljs-comment">// this mutation, in addition to the ID of the story.</span>
  static fragments = {
    story: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`
      fragment on <span class="hljs-type">Story</span> {
        id,
        likers { count },
        viewerDoesLike,
      }
    `,
  };
  <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<p>You don't have to mimic the entire response payload. Here, we've punted on the like sentence, since it's difficult to localize on the client side. When the server responds, Relay will treat its payload as the source of truth, but in the meantime, the optimistic response will be applied right away, allowing the people who use our product to enjoy instant feedback after having taken an action.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/relay/" class="nav-home"><img src="/relay/img/relay.svg" alt="Relay" width="66" height="58"/></a><div><h5>Docs</h5><a href="/relay/docs/en/introduction-to-relay.html">Introduction</a></div><div><h5>Community</h5><a href="/relay/en/users.html">User Showcase</a></div><div><h5>More</h5><a href="https://github.com/facebook/relay">GitHub</a><a class="github-button" href="https://github.com/facebook/relay" data-icon="octicon-star" data-count-href="/facebook/relay/stargazers" data-count-api="/repos/facebook/relay#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/relay/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2019 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '3d7d5825d50ea36bca0e6ad06c926f06',
                indexName: 'relay',
                inputSelector: '#search_input_react'
              });
            </script></body></html>